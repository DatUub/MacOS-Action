"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratePage = void 0;
const discord_js_1 = require("discord.js");
const types_js_1 = require("../types.js");
const Paginate_js_1 = require("./Paginate.js");
function GeneratePage(item, page, maxPage, config) {
    const beginning = page === 0;
    const end = page === maxPage - 1;
    const newMessage = item;
    function isStartEndAllowed() {
        if (config.showStartEnd === undefined) {
            return true;
        }
        if (typeof config.showStartEnd === "number") {
            return maxPage >= config.showStartEnd;
        }
        return config.showStartEnd;
    }
    /**
     * Pagination type button
     */
    if (config.type === types_js_1.PaginationType.Button) {
        const startBtn = new discord_js_1.ButtonBuilder()
            .setCustomId(config.start?.id ?? types_js_1.defaultIds.buttons.start)
            .setLabel(config.start?.label ?? "Start")
            .setStyle(config.start?.style ?? discord_js_1.ButtonStyle.Primary)
            .setDisabled(beginning);
        const endBtn = new discord_js_1.ButtonBuilder()
            .setCustomId(config.end?.id ?? types_js_1.defaultIds.buttons.end)
            .setLabel(config.end?.label ?? "End")
            .setStyle(config.end?.style ?? discord_js_1.ButtonStyle.Primary)
            .setDisabled(end);
        const nextBtn = new discord_js_1.ButtonBuilder()
            .setCustomId(config.next?.id ?? types_js_1.defaultIds.buttons.next)
            .setLabel(config.next?.label ?? "Next")
            .setStyle(config.next?.style ?? discord_js_1.ButtonStyle.Primary)
            .setDisabled(end);
        const prevBtn = new discord_js_1.ButtonBuilder()
            .setCustomId(config.previous?.id ?? types_js_1.defaultIds.buttons.previous)
            .setLabel(config.previous?.label ?? "Previous")
            .setStyle(config.previous?.style ?? discord_js_1.ButtonStyle.Primary)
            .setDisabled(beginning);
        const exitBtn = new discord_js_1.ButtonBuilder()
            .setCustomId(config.exit?.id ?? types_js_1.defaultIds.buttons.exit)
            .setLabel(config.exit?.label ?? "Exit")
            .setStyle(config.exit?.style ?? discord_js_1.ButtonStyle.Danger);
        // set emoji
        if (config.start?.emoji) {
            startBtn.setEmoji(config.start.emoji);
        }
        if (config.end?.emoji) {
            endBtn.setEmoji(config.end.emoji);
        }
        if (config.next?.emoji) {
            nextBtn.setEmoji(config.next.emoji);
        }
        if (config.previous?.emoji) {
            prevBtn.setEmoji(config.previous.emoji);
        }
        if (config.exit?.emoji) {
            exitBtn.setEmoji(config.exit.emoji);
        }
        const buttons = [prevBtn, nextBtn];
        if (isStartEndAllowed()) {
            buttons.unshift(startBtn);
            buttons.push(endBtn);
        }
        if (config.enableExit) {
            buttons.push(exitBtn);
        }
        const row = new discord_js_1.ActionRowBuilder().addComponents(buttons);
        // reset message payload additional parameters
        if (!newMessage.embeds) {
            newMessage.embeds = [];
        }
        if (!newMessage.files) {
            newMessage.files = [];
        }
        if (!newMessage.files) {
            newMessage.files = [];
        }
        if (!newMessage.attachments) {
            newMessage.attachments = [];
        }
        return { newMessage, paginationRow: row };
    }
    /**
     * Pagination type select menu
     */
    const paginator = (0, Paginate_js_1.Paginate)(maxPage, page, 1, 21).pages.map((i) => {
        // get custom page title
        const text = config.pageText instanceof Array
            ? config.pageText[i - 1]
            : config.pageText;
        return {
            label: (text ?? "Page {page}").replaceAll("{page}", `${i}`),
            value: (i - 1).toString(),
        };
    });
    if (isStartEndAllowed()) {
        // add start option
        paginator.unshift({
            label: config.labels?.start ?? "Start",
            value: types_js_1.SelectMenuPageId.Start.toString(),
        });
        // add end option
        paginator.push({
            label: config.labels?.end ?? "End",
            value: types_js_1.SelectMenuPageId.End.toString(),
        });
    }
    // add exit option
    if (config.enableExit) {
        paginator.push({
            label: config.labels?.exit ?? "Exit Pagination",
            value: types_js_1.SelectMenuPageId.Exit.toString(),
        });
    }
    const menu = new discord_js_1.StringSelectMenuBuilder()
        .setCustomId(config.menuId ?? types_js_1.defaultIds.menu)
        .setPlaceholder(config.placeholder ?? "Select page")
        .setOptions(paginator);
    const row = new discord_js_1.ActionRowBuilder().addComponents([
        menu,
    ]);
    // reset message payload additional parameters
    if (!newMessage.embeds) {
        newMessage.embeds = [];
    }
    if (!newMessage.files) {
        newMessage.files = [];
    }
    if (!newMessage.files) {
        newMessage.files = [];
    }
    if (!newMessage.attachments) {
        newMessage.attachments = [];
    }
    return { newMessage, paginationRow: row };
}
exports.GeneratePage = GeneratePage;
//# sourceMappingURL=GeneratePage.js.map